// (c) Yuri N. K. 2025. All rights reserved.
// ykasczc@gmail.com

#pragma once

#include "CoreMinimal.h"
#include "NNERuntimeCPU.h"
#include "DSP/AlignedBuffer.h"
#include "LocalTTSTypes.generated.h"

class UNNEModelData;
class UTTSModelData_Base;

// Helpers for android support
namespace PlatformFileUtils
{
	// Fix invalid delimiters in the path
	void NormalizePath(FString& Path);

	// Return absolute actual path on storage device from the Unreal path
	// For Windows they're equal 
	FString GetPlatformPath(FString Path);

	// Check if directory exists on physical disk
	bool DirectoryExists(const FString& Dir);
}

namespace Piper
{
	typedef char32_t PhonemeUtf8;
	typedef int64_t PhonemeId;
}

/**
* Phonemization approach (not in use)
*/
UENUM(BlueprintType)
enum class ETTSPhonemeType : uint8
{
	PT_eSpeak				UMETA(DisplayName = "eSpeak"),
	PT_Dictionary			UMETA(DisplayName = "Dictionary + G2P NNM"),
	PT_NNM					UMETA(DisplayName = "G2P NNM")
};

// Container for NNM instance key in ULocalTTSSubsystem
USTRUCT(BlueprintType, meta=(DisplayName = "TTS Model Instance ID"))
struct FNNMInstanceId
{
	GENERATED_BODY()

	// Key in ULocalTTSSubsystem::VoiceModels
	UPROPERTY()
	int32 Id = INDEX_NONE;

	FNNMInstanceId() {}
	FNNMInstanceId(int32 Index) : Id(Index) {}
	FNNMInstanceId& operator=(int32 Value)
	{
		Id = Value; return *this;
	}
	bool operator==(int32 Value) const
	{
		return Id == Value;
	}
};

// NNM input index to data buffer
USTRUCT()
struct FNNEModelInputBinding
{
	GENERATED_BODY()

	// Data format in NNM input
	ENNETensorDataType Format = ENNETensorDataType::None;
	// Corresponding array index
	int32 ArrayIndex = INDEX_NONE;
};

/**
* Generic TTS ONNX model with input and output settings
*/
USTRUCT()
struct FNNEModelTTS
{
	GENERATED_BODY()

protected:
	FGuid Guid;

public:
	TObjectPtr<UTTSModelData_Base> VoiceDesc = nullptr;
	FString ModelAssetName;

	// NNE Setup

	// NNE Model
	TSharedPtr<UE::NNE::IModelInstanceCPU> ModelInstance;
	// Inputs
	TArray<UE::NNE::FTensorBindingCPU> InputBindings;
	// Outputs (just one, just float)
	TArray<UE::NNE::FTensorBindingCPU> OutputBindings;

	// Tensor buffers

	// Universal input mapping
	TArray<FNNEModelInputBinding> InputMap;
	TArray<TArray<float>> InputDataFloat;
	TArray<TArray<int64>> InputDataInt64;
	// Outputs
	TArray<float> OutputData;
	// Shapes applied before RunSync
	TArray<UE::NNE::FTensorShape> InputTensorShapes;

	// Model is loaded
	bool bLoaded = false;

	// Using GUID for operator==
	FNNEModelTTS() : Guid(FGuid::NewGuid()) {}

	bool operator==(const FNNEModelTTS& Other) const { return Guid == Other.Guid; }
	FString GetGUID() const { return Guid.ToString(); }

	// Get reference to input tensor by Index
	TArray<int64>& GetInParamIntUnsafe(const int32 Index);
	// Get reference to input tensor by Index
	TArray<float>& GetInParamFloatUnsafe(const int32 Index);
	// Get if input exists
	bool CheckInParam(const int32 Index, ENNETensorDataType Type) const;
	// Reserve memory for RunSync output
	void PrepareOutputBuffer(int32 Size);

	// Set input parameters
	bool PrepareInputFloat(int32 Index, const TArray<float>& Data, const TArrayView<const uint32>& Shape);
	bool PrepareInputInt64(int32 Index, const TArray<int64>& Data, const TArrayView<const uint32>& Shape);
	// Run and get output tensor
	bool RunNNE(TArray<float>& OutData, TArray<uint32>& OutDataShape, bool bReturnData = true);
};

/**
* Non-static text-to-speech generation settings
*/
USTRUCT(Blueprintable)
struct FTTSGenerateSettings
{
	GENERATED_BODY()

	// Numeric ID of speaker in the model. Use -1 for models without speakers map.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "TTS Generate Settings")
	int32 SpeakerId = INDEX_NONE;
};

/**
* Model parameters; internal; used to fill NNM inputs
*/
USTRUCT()
struct FTTSGenerateRequestContext
{
	GENERATED_BODY()

	// ID of speaker in the model
	UPROPERTY()
	int32 SpeakerId = INDEX_NONE;

	// Pointer to tokens
	const TArray<Piper::PhonemeId>* Tokens = nullptr;
};

/**
* All data generated by NNM
*/
USTRUCT()
struct FSynthesisResult
{
	GENERATED_BODY()

	// Voice
	FNNMInstanceId ModelTag;

	// Phonemized input data
	TArray<TArray<Piper::PhonemeUtf8>> PhonemePhrases;

	// Generated audio duration
	double AudioSeconds = 0.0;

	// Final post-processed sample rate of PCMData32 and PCMData16
	int32 SampleRate = 0;

	// Primary audio buffer (32-bit)
	Audio::FAlignedFloatBuffer PCMData32;
	// Buffer converted to 16-bit format
	TArray<uint8> PCMData16;

	void Reset(const FNNMInstanceId& NewVoice)
	{
		ModelTag = NewVoice;
		AudioSeconds = 0.f;
		PCMData16.Empty();
		PhonemePhrases.Empty();
	}
};
